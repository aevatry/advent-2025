#include "helpers/array.h"
#include "helpers/sorting.h"
#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define LINE_LENGTH 256
#define ARRAY_SIZE_N 1024
#define ARRAY_SIZE_M 2

typedef enum { false, true } bool;
typedef enum { up, down, left, right } dir;

typedef struct Bounday {
    int start_x;
    int stop_x;
    int start_y;
    int stop_y;
    dir direction;
} Boundary;

typedef struct BoundedVec {
    int start;
    int stop;
} BoundedVec;

void print_2d_int_array(IntArray *array) {
    // Printing the 2D array
    for (int i = 0; i <= array->n; i++) {
        for (int j = 0; j <= array->m; j++) {
            printf("%i ", array->data[i][j]);
        }
        printf("\n"); // Move to the next row
    }
};

int construct_int_from_chars(int length_num, char *chars) {

    int result = 0;
    for (int i = 1; i <= length_num; i++) {
        result += (chars[i - 1] - '0') * (int)pow(10, length_num - i);
    }
    return result;
};

long absolute_l(long a) { return (a >= 0) * a - (a < 0) * a; };

void get_ij_from_pascal_idx(int pascal_idx, int i_start, int *i, int *j) {
    bool is_ij_found = false;

    if (pascal_idx < i_start * (i_start + 1) / 2) {
        i_start = 0;
    }

    while (is_ij_found == false) {
        int lower_b = i_start * (i_start + 1) / 2;
        int higher_b = (i_start + 1) * (i_start + 2) / 2;

        if (lower_b <= pascal_idx && pascal_idx < higher_b) {
            *i = i_start;
            *j = pascal_idx - lower_b;
            is_ij_found = true;
        }

        i_start++;
    }
}

void increment_turn_counter(Boundary prev, Boundary current, int *turn_counter) {
    int dx1 = prev.stop_x - prev.start_x;
    int dx2 = current.stop_x - current.start_x;
    int dy1 = prev.stop_y - prev.start_y;
    int dy2 = current.stop_y - current.start_y;

    // right turn
    if ((dx1 > 0 && dy2 > 0) || (dx1 < 0 && dy2 < 0) || (dy1 > 0 && dx2 < 0) ||
        (dy1 < 0 && dx2 > 0)) {
        *turn_counter += 1;
    } else {
        *turn_counter -= 1;
    }
};

int main() {

    /*
     * FILE PROCESSING
     */

    FILE *input_file;
    input_file = fopen("input.txt", "r");
    if (input_file == NULL) {
        printf("The file is not opened.");
        fclose(input_file);
        return EXIT_FAILURE;
    }

    /*Each line ends with 2 characters -> newline/line feed (ASCII 10) and NULL (ASCII 0)  */
    char line[LINE_LENGTH];

    // start state of the problem
    IntArray *positions = create_array_i(ARRAY_SIZE_N, ARRAY_SIZE_M);
    fill_array_i(0, positions);

    // setup of problem variables
    int line_counter = 0;

    // counting turns of the boundary
    Boundary *boundaries = malloc(ARRAY_SIZE_N * sizeof(boundaries[0]));
    int num_clockwise_turns = 0;

    while (fgets(line, LINE_LENGTH, input_file) != NULL) {

        // reset line interpretation
        bool has_reached_eol = false;
        int in_line_idx = 0;
        int number_length = 0;
        char num_buffer[16];
        int comma_counter = 0;

        // !! assumption -> input is well formatted
        while (has_reached_eol == false) {

            /*
             * NUMBER READING
             */
            // add to the number buffer if it is a number
            if ((int)'0' <= line[in_line_idx] && line[in_line_idx] <= '9') {
                num_buffer[number_length] = line[in_line_idx];
                number_length++;
            }

            if (line[in_line_idx + 1] == ',' || (int)line[in_line_idx + 1] == 10) {
                int val = construct_int_from_chars(number_length, num_buffer);
                put_val_in_array_i(val, line_counter, comma_counter, positions);
                comma_counter++;
                number_length = 0;
            }

            /*
             * END OF LINE
             */

            in_line_idx++;
            // line end condition
            if ((int)line[in_line_idx] == 10) {
                has_reached_eol = true;
            }
        }

        /*
         * Construction of the boundaries and count turning
         */
        if (line_counter == 0) {
            /*Cannot construct a boundary with 1 point */
        } else if (line_counter == 1) {
            Boundary curr_b = {
                .start_x = positions->data[line_counter - 1][0],
                .stop_x = positions->data[line_counter][0],
                .start_y = positions->data[line_counter - 1][1],
                .stop_y = positions->data[line_counter][1],
            };
            boundaries[line_counter - 1] = curr_b;
        } else {
            Boundary curr_b = {
                .start_x = positions->data[line_counter - 1][0],
                .stop_x = positions->data[line_counter][0],
                .start_y = positions->data[line_counter - 1][1],
                .stop_y = positions->data[line_counter][1],
            };
            boundaries[line_counter - 1] = curr_b;
            increment_turn_counter(boundaries[line_counter - 2], boundaries[line_counter - 1],
                                   &num_clockwise_turns);
        }

        line_counter++;
    }
    /* At end, still need to construct boundary between last and 1st point */

    Boundary curr_b = {
        .start_x = positions->data[line_counter][0],
        .stop_x = positions->data[0][0],
        .start_y = positions->data[line_counter][1],
        .stop_y = positions->data[0][1],
    };
    boundaries[line_counter] = curr_b;
    increment_turn_counter(boundaries[line_counter - 1], boundaries[0], &num_clockwise_turns);

    printf("There are %i turns total", num_clockwise_turns);

    /*
     * PROBLEM LOGIC
     */

    // construct boundaries directions
    int num_boundaries = line_counter + 1;
    for (int i = 0; i < line_counter + 1; i++) {
        // first boundary scenario
        if (i == 0) {
            int x_start = positions->data[i][0];
            int x_stop = positions->data[i + 1][0];
            int y_start = positions->data[i][1];
            int y_stop = positions->data[i + 1][1];
        }
    }

    // Calculate pairwise distances
    int num_pairs = line_counter * (line_counter + 1) / 2;
    long *pairwise_area = (long *)malloc(num_pairs * sizeof(pairwise_area[0]));
    int *area_idxs = (int *)malloc(num_pairs * sizeof(area_idxs[0]));

    for (int i = 0; i < line_counter; i++) {
        for (int j = 0; j <= i; j++) {
            // if no connection already exist
            long dx = absolute_l(positions->data[i][0] - positions->data[j][0]) + 1;
            long dy = absolute_l(positions->data[i][1] - positions->data[j][1]) + 1;
            long area = dx * dy;
            pairwise_area[i * (i + 1) / 2 + j] = area;
            area_idxs[i * (i + 1) / 2 + j] = i * (i + 1) / 2 + j;
        }
    }

    // !! the actual index of the last element is num_pairs - 1, not num_pairs
    quick_sort_l(pairwise_area, area_idxs, 0, num_pairs - 1);
    printf("Largest area is %li \n", pairwise_area[num_pairs - 1]);

    // memory management
    free(pairwise_area);
    free(area_idxs);
    free(boundaries);
    free_array_i(positions);

    fclose(input_file);
    return EXIT_SUCCESS;
}
